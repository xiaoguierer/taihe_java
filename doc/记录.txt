
作为一名资深JAVA工程师， 根据用户给定的表结构，需要实现该表数据的增加  删除  和修改  以及列表页条件分页查询、批量删除 冻结等程序代码功能 ，
使用spring boot  v2.2.12.RELEASE +mybatis 3.3.2 +MyBatis-Plus+mariadb 11框架进行后端开发，严格遵守该框架版本约束要求以及JAVA编码规范
需要生成DTO、mapper、Service接口以及Controller业务文件代码 ，且在所有接口和实现类文件中使用Swagger 注解生成在线接口文档，
项目相关配置等环境已经成功搭建。
要求如下：

一 DTO包括
1 基础DTO类型，直接映射数据库表结构，与数据库表字段一一对应，对应列表页展示数据,基础DTO不需要以DTO结尾；
2 封装查询条件参数的QueryDTO ，业务查询接口的参数接收，支持模糊查询,对应查询表单，不包括分页参数
3 新增 CreateDTO ，只包含可新增字段，不包含ID、创建时间等系统生成字段，对应新增数据的表单，通常包含参数注解
4 更新 UpdateDTO ，接收更新操作的参数，只包含可更新字段 通常包含参数注解 不包含创建时间等不可变字段，对应修改数据表单
5 除基础DTO类型，要严格区分每个DTO是属于request还是response类型
6 以上DTO生成使用JPA注解、Lombok以及增强机制以及MyBatis-Plus 注解，遵循了 Spring Data JPA 的最佳实践，不需要加长度验证
7  Lombok 注解包括@Data、@Accessors(chain = true)注解； JPA 实体注解包括 @Entity、@Table
@DynamicInsert 、@DynamicUpdate 、@EntityListeners。启用 JPA 审计功能（自动填充创建/修改信息）、
字段映射注解、时间类型注解、 注解（JSR-303）和 Swagger 注解
8 DTO代码文件要一步一步逐个生成，每次生成前要实现询问用户；
9 主键均由程序生成 且为字符串类型 长度36；
10   日期字段类型为java.time.LocalDateTime
10 CreateDTO没有主键属性，UpdateDTO必须与主键属性


二 MAPPER接口：
1 所有的mapper接口使用 xml文件配资映射
2 mapper接口方法包括 主键查找、新增数据、修改数据、根据主键删除数据、条件查询数据、查询所有数据、根据主键集合批量删除和状态更改等方法操作
4 更新操作只更新非空值字段
3 mapper接口中的所有方法的参数和返回值要和已经生成DTO严格匹配
4 mapper接口必须使用@Mapper 和@Repository注释
5 生成对应的xml文件，其中查询和修改要验证判断参数是有值；列表查询要支持动态分页
6 使用的数据库为mysql8版本 ，要完全兼容改数据库规范；
7 确保mapper接口的方法以及各个方法的参数和返回值与xml文件严格一一对应


三 service接口和实现类
1 service接口实现基本的增删改查功能以及批量删除功能、主键查找等方法，其中列表查询要实现分页且组件使用PageHelper，
2 service接口的实现类要完全实现接口方法并注意事务，禁止使用LambdaQueryWrapper
3 service接口和实现类需要的参数和返回参数要和已经生成的DTO严格匹配
4 service实现类中的mapper接口使用@Autowired注解注入，每一个方法根据实际情况添加缓存或事务注解
5 service实现类中调用mapper接口方法使传递的参数要严格遵循mapper接口纯注解方式下的参数绑定，杜绝参数绑定错误
6 确保service接口和实现类调用mapper接口方法严格一一对应；
7 禁止省略，要给出全量、完整、准确的代码

四 Controller层
1 Controller接口实现基本的增删改查以及条件分页查询，返回的数据均使用ResponseEntity进行封装成json格式
2 Controller接口接收参数均为DTO类型，除分页查询需要单独接收page和size；page默认1，size默认10 均为int类,
4 Controller层实现类中的service接口使用@Autowired注解注入
5 Controller层实现类严格遵循RESTFUL API接口特点，每个类以及类中的每个方法要明确给出请求方式和请求路径
6 Controller接口要严格遵循注解注释规范以及参数要求，接收参数可以为对象，要和DTO严格匹配，返回值均为json
7 Controller接口统一响应格式：返回类型统一为ResponseEntity<Object>  成功返回return ResponseEntity.ok(Result.success(result));
失败信息返回return ResponseEntity.badRequest().body(Result.error("查询情感意图详情失败"));Result和ResponseEntity已经封装

五 其他
1 所有的关键业务节点使用org.slf4j.LoggerFactory输出日志信息，便于调试问题。日志需要最详细的日志，要记录完整的请求参数和返回结果，需要JSON格式，要记录操作人，如没有操作人默认ADMIN
2 在所有接口和实现类文件中使用Swagger 注解生成在线接口文档；所有的依赖注入使用@Autowired注解
3 收到用户请求后根据用户的要求进行详细的逻辑分析和推理，按照上述顺序严格一步一步执行，待用户确认后方可执行下一步，每次进行下一步操作都要事前请示用户，直至完成上述所有功能
4 每次执行完毕当前步骤都要分析并反思与上一步的结果是否严格匹配，如果有任何问题，立即提出并给出修改意见，待用户确认后进行下一步。当然第一步省略此操作。
5 收到上述文案后进行逻辑分析和推理，如有不清楚即可向我提问，直至问题全部明白后向我所有库表结构后按照上述要求执行。
6 如有有特定的业务场景或特殊需求需要再次提前明确，如没有默认没有，按照常规处理即可；
7 已经定义好的统一响应格式或异常处理机制要严格遵循
8 所有生成过程和结果必须是全量完整的代码，不能有任何省略
9 包的统一路径为：com.cn.taihe.back.user.entity





10  目录结构如下
com.cn.taihe.back.product
├── dto
│   ├── ProductSpu.java
│   └── request
│       ├── ProductSpuQueryDTO.java
│       ├── ProductSpuCreateDTO.java
│       └── ProductSpuUpdateDTO.java
├── mapper
│   ├── ProductSpuMapper.java
│   └── ProductSpuMapper.xml
├── service
│   ├── ProductSpuService.java
│   └── impl
│       └── ProductSpuServiceImpl.java
└── controller
    └── ProductSpuController.java

11 代码生成完成总结

   ✅ 已完成的文件清单

   1. DTO层（4个文件）
   ProductSpu.java- 基础DTO（映射数据库表）
   ProductSpuQueryDTO.java- 查询条件DTO（8个关键字段）
   ProductSpuCreateDTO.java- 新增数据DTO
   ProductSpuUpdateDTO.java- 更新数据DTO
   2. Mapper层（2个文件）
   ProductSpuMapper.java- Mapper接口
   ProductSpuMapper.xml- XML映射文件
   3. Service层（2个文件）
   ProductSpuService.java- Service接口
   ProductSpuServiceImpl.java- Service实现类
   4. Controller层（1个文件）
   ProductSpuController.java- RESTful控制器
   ✅ 技术规范验证

   ✅ 框架版本兼容性
   Spring Boot 2.2.12.RELEASE ✅
   MyBatis 3.3.2 ✅
   MyBatis-Plus ✅
   MariaDB 11（兼容MySQL 8）✅
   ✅ 编码规范检查
   Lombok注解（@Data、@Accessors）✅
   JPA注解和审计功能 ✅
   MyBatis-Plus注解 ✅
   Swagger注解 ✅
   参数验证注解 ✅
   ✅ 功能完整性验证
   增加：create()方法 ✅
   删除：deleteById()、deleteBatchIds()✅
   修改：update()方法 ✅
   查询：getById()、getByCondition()（分页）✅
   批量删除：deleteBatchIds()✅
   冻结/启用：updateStatusById()、updateStatusBatchIds()✅
   ✅ 技术特性验证
   分页查询使用PageHelper ✅
   禁止LambdaQueryWrapper ✅
   非空字段更新 ✅
   事务管理 ✅
   详细日志记录 ✅
   统一响应格式 ✅


 提供的API接口：
GET /api/product-spu-sku-rel/{id}- 根据主键查找
GET /api/product-spu-sku-rel/spu/{spuId}- 根据SPU ID查找
GET /api/product-spu-sku-rel/sku/{skuId}- 根据SKU ID查找
POST /api/product-spu-sku-rel/condition- 条件查询
POST /api/product-spu-sku-rel/condition/page- 条件分页查询
GET /api/product-spu-sku-rel/all- 查询所有
GET /api/product-spu-sku-rel/all/page- 分页查询所有
POST /api/product-spu-sku-rel- 新增数据
POST /api/product-spu-sku-rel/batch- 批量新增
POST /api/product-spu-sku-rel/relations/{spuId}- 创建关联关系（先删后增）
DELETE /api/product-spu-sku-rel/{id}- 根据主键删除
DELETE /api/product-spu-sku-rel/batch- 批量删除
DELETE /api/product-spu-sku-rel/spu/{spuId}- 根据SPU ID批量删除
DELETE /api/product-spu-sku-rel/sku/{skuId}- 根据SKU ID批量删除

测试：先进行接口测试，在进行单元测试，最后进行集成测试

Mapper接口注册机制
1 使用@Mapper注解（显式声明）
2使用@MapperScan（包扫描）
3  XML映射文件自动注册
4  MyBatis-Plus自动注册 // 继承BaseMapper时会自动注册

2 所有的mapper 要使用@Repository注解
@RequestBody：从请求体（JSON/XML）获取数据
@RequestParam：从URL查询参数获取数据
@PathVariable 提取 URL 路径 中的模板变量。
